[TOC]

有几种操作适用于所有序列，包括索引、切片、迭代、相加、相乘和成员资格检查。另外，Python
还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。



## 索引

序列中的所有元素都有编号——从0开始递增

```python
>>> str = 'Hello'
>>> str[0]
'H'
```

> 字符串就是由字符组成的序列。索引0指向第一个元素，这里为字母H。不同于其他一些语言，Python没有专门用于表示字符的类型，因此一个字符就是只包含一个元素的字符串。

当你使用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此-1是最后一个元素的位置。

```python
>>> str[-1]
'o'
```



## 切片

除使用索引来访问单个元素外，还可使用切片（slicing）来访问特定范围内的元素。为此，可使用两个索引，并用冒号分隔：

```python
>>> text = '<a href="http://www.python.org">Python web site</a>'
>>> text[32:-4]
'Python web site'
```

切片适用于提取序列的一部分，其中的编号非常重要：第一个索引是包含的第一个元素的编号，但第二个索引是切片后余下的第一个元素的编号。

```python
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[3:6] 
[4, 5, 6]
>>> numbers[0:1] 
[1]
```

简而言之，你提供两个索引来指定切片的边界，其中第一个索引指定的元素包含在切片内，但第二个索引指定的元素不包含在切片内。

如果要从列表末尾开始数，可使用负数索引:

```python
>>> numbers[-3:-1]
[8, 9]
```

然而，这样好像无法包含最后一个元素。如果使用索引0，即到达列表末尾后再前进一步所处的位置，结果将如何呢？

```python
>>> numbers[-3:0]
[]
```
结果并不是你想要的。事实上，执行切片操作时，如果第一个索引指定的元素位于第二个索引指定的元素后面（在这里，倒数第3个元素位于第1个元素后面），结果就为空序列。

好在可以使用一种简写：如果切片结束于序列末尾，可省略第二个索引。
```python
>>> numbers[-3:]
[8, 9, 10]
```
同样，如果切片始于序列开头，可省略第一个索引。
```python
>>> numbers[:3]
[1, 2, 3]
```
实际上，要复制整个序列，可将两个索引都省略
```python
>>> numbers[:]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
执行切片操作时，你显式或隐式地指定起点和终点，但通常省略另一个参数，即步长。在普通切片中，步长为1。这意味着从一个元素移到下一个元素，因此切片包含起点和终点之间的所有元素。
```python
>>> numbers[0:10:1]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
如果指定的步长大于1，将跳过一些元素。例如，步长为2时，将从起点和终点之间每隔一个元素提取一个元素:
```python
>>> numbers[0:10:2]
[1, 3, 5, 7, 9]
>>> numbers[3:6:3]
[4]
```
显式地指定步长时，也可使用前述简写。例如，要从序列中每隔3个元素提取1个，只需提供步长4即可:
```python
>>> numbers[::4]
[1, 5, 9]
```
当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素：
```python
>>> numbers[8:3:-1]
[9, 8, 7, 6, 5]
>>> numbers[10:0:-2]
[10, 8, 6, 4, 2]
>>> numbers[0:10:-2]
[]
>>> numbers[::-2]
[10, 8, 6, 4, 2]
>>> numbers[5::-2]
[6, 4, 2]
>>> numbers[:5:-2]
[10, 8]
```
> 第一个索引依然包含在内，而第二个索引不包含在内。
>
> 步长为负数时，第一个索引一定要比第二个索引大（步长为正数时，第二个索引必须比第一个索引大）
>
> 步长为正数时，它从起点移到终点，而步长为负数时，它从终点移到起点。



## 序列相加

可使用加法运算符来拼接序列：

```python
>>> [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
>>> 'Hello,' + 'world!'
'Hello, world!'
>>> [1, 2, 3] + 'world!'
Traceback (innermost last):
File "<pyshell>", line 1, in ?
[1, 2, 3] + 'world!'
TypeError: can only concatenate list (not "string") to list
```

从错误消息可知，不能拼接列表和字符串，虽然它们都是序列。一般而言，不能拼接不同类型的序列。

## 乘法

将序列与数n相乘时，将重复这个序列n次来创建一个新序列：

```python
>>> 'python' * 5
'pythonpythonpythonpythonpython'
>>> [42] * 10
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
```



## 成员资格

### 是否包含

要检查特定的值是否包含在序列中，可使用运算符 in。它检查是否满足指定的条件，并返回相应的值：满足时返回 True ，
不满足时返回 False 。

```python
>>> permissions = 'rw'
>>> 'w' in permissions
True
>>> 'x' in permissions
False
>>> users = ['mlh', 'foo', 'bar']
>>> input('Enter your user name: ') in users
Enter your user name: mlh
True
>>> subject = '$$$ Get rich now!!! $$$'
>>> '$$$' in subject
True
```

> 相比于其他示例，检查字符串是否包含 '$$$' 的示例稍有不同。一般而言，运算符 in 检查
> 指定的对象是否是序列（或其他集合）的成员（即其中的一个元素），但对字符串来说，
> 只有它包含的字符才是其成员或元素，因此下面的代码完全合理：
> ```python
> >>>'P' in 'Python'
> True
> ```
> 事实上，在较早的Python版本中，只能对字符串执行这种成员资格检查——确定指定的字符是否>  包含在字符串中，但现在可使用运算符 in 来检查指定的字符串是否为另一个字符串的子串。

### 长度、最小值和最大值

函数 len 返回序列包含的元素个数，而 min 和 max 分别返回序列中最小和最大的元素：

```python
>>> numbers = [100, 34, 678]
>>> len(numbers)
3
>>> max(numbers)
678
>>> min(numbers)
34
```



## 迭代

如果给定一个`list`或`tuple`，我们可以通过`for`循环来遍历这个`list`或`tuple`，这种遍历我们称为迭代（Iteration）。

```python
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> for key in d:
...     print(key)
...
a
c
b
```

